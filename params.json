{"name":"BTHEventSource","body":"BTHEventSource\r\n=\r\n\r\n**Cross-browser Server-Sent Events Wrapper**\r\n\r\nThis is a small and experimental wrapper for EventSource. It's intended to work out differences between browser implementations and provide XHR long-polling fallback when EventSource isn't available.\r\n\r\nRequirements\r\n-\r\n\r\nThe only requirement is `window.JSON` object. If you target browsers that don't provide a native JSON implementation (e.g. IE 6/7) then it's required that you provide it. The usual (and recommended) implementation is [JSON-js](https://github.com/douglascrockford/JSON-js).\r\n\r\nBackend\r\n-\r\n\r\nJSON is used as data format for all the messages, regardless of transport. When working with SSE the backend should set Content-Type header to \"text/event-stream\" (for Firefox and WebKits) or \"application/x-dom-event-stream\" (for Opera). EventSource URL will be passed an additional query string parameter `opera=1` to indicate that the UA is Opera. In case of XHR long-polling respond with \"application/json\".\r\n\r\nXHR long-polling response format:\r\n\r\n```javascript\r\n{ 'id': 1234567890, 'event': 'event-name', 'data': 'event-data' }\r\n```\r\n\r\nThe only required field is `data`. The `id` and `event` correspond to `id` and `event` fields of event stream. Consult [this tutorial](http://www.html5rocks.com/en/tutorials/eventsource/basics/) if you need more info. `retry` field isn't supported.\r\n\r\nEvent ID will be passed as an EventSource URL query string parameter `last_event_id` if previous request timed out or returned an error. If previous request was successful but no data was received (e.g. due to lack of data to send from backend) then Event ID won't be passed to the backend.\r\n\r\nCheck out `backend/btheventsource.py` for an example implementation for Tornado 2.\r\n\r\nFrontend\r\n-\r\n\r\n### Installation\r\n\r\n```javascript\r\nvar source = window.BTHEventSource('/events');\r\nvar xhr_source = window.BTHEventSource('/events', true);\r\n```\r\n\r\nThe first argument is the URL of event stream. The second is optional and if you provide anything that's not `undefined` you'll force XHR long-polling.\r\n\r\n### Registering event handlers\r\n\r\n```javascript\r\nsource.open(function() { alert('The connection was opened!'); });\r\nsource.close(function() { alert('The connection was closed :(.'); });\r\nsource.error(function() { alert('Communication error. Crap.'); });\r\nsource.message(function(data) { alert('Received an unnamed event.'); });\r\nsource.message('myEvent', function(data) { alert('Received \"myEvent\" event.'); });\r\n```\r\n\r\n### Interacting with the source\r\n\r\n```javascript\r\nsource.start();\r\nsource.stop();\r\n```\r\n\r\n### Caveats\r\n\r\n* To open the communication channel (regardless of transport) you have to call `start()` explicitly,\r\n* `open` event will fire after the transport receives the very first event. This applies both to SSE and XHR transports. Note that SSE behavior is browser-dependent and may change,\r\n* `close` event will not be fired on Opera because the browser doesn't fire internal SSE `error` event when the connection is closed,\r\n* `close` event will be fired for **every** XHR request that times out,\r\n* cross-domain requests aren't supported.\r\n\r\nBrowser compatibility\r\n-\r\n\r\nI tested the wrapper on IE 6/7/8, FF 3.6/6/7, Safari 5, Chrome 14 and Opera 11.51 running under Mac OS X 10.6 and/or Windows XP.\r\n\r\nExample\r\n-\r\n\r\nUnder `examples/chat/` you'll find a small Tornado chat app that uses BTHEventSource to deliver updates to users. It's not perfect but does the job of both working and showing the wrapper in action.\r\n\r\nLicense\r\n-\r\n\r\nMIT-style, see LICENSE.","tagline":"Cross-browser Server-Sent Events Wrapper","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}